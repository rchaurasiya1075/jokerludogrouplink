<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO Game - Two Players</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
        }
        
        h1 {
            font-size: 3.5rem;
            margin-bottom: 5px;
            color: #ffcc00;
            text-shadow: 3px 3px 0 #ff3300;
            letter-spacing: 3px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 900px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .players-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 30px;
        }
        
        .player {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.1);
            width: 45%;
            transition: all 0.3s;
        }
        
        .player.active {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 15px gold;
        }
        
        .player-name {
            font-size: 1.4rem;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .player-cards {
            font-size: 1.2rem;
        }
        
        .game-board {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            position: relative;
        }
        
        .deck-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 50px;
            margin: 20px 0;
            width: 100%;
        }
        
        .deck {
            width: 100px;
            height: 150px;
            border-radius: 10px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.8rem;
            position: relative;
            cursor: pointer;
        }
        
        .deck::after {
            content: 'UNO';
            position: absolute;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .discard-pile {
            width: 100px;
            height: 150px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2rem;
            font-weight: bold;
            position: relative;
        }
        
        .card-back {
            background: repeating-linear-gradient(
                45deg,
                #3498db,
                #3498db 10px,
                #2980b9 10px,
                #2980b9 20px
            );
        }
        
        .card-back::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 2px solid white;
            border-radius: 5px;
        }
        
        .player-hand {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin: 30px 0;
            min-height: 160px;
            width: 100%;
        }
        
        .opponent-hand {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin: 30px 0;
            min-height: 160px;
            width: 100%;
        }
        
        .card {
            width: 80px;
            height: 120px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }
        
        .card:hover {
            transform: translateY(-15px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }
        
        .card-value {
            font-size: 1.8rem;
            z-index: 1;
        }
        
        .card-color {
            font-size: 0.8rem;
            text-transform: uppercase;
            z-index: 1;
        }
        
        .red {
            background: linear-gradient(135deg, #ff5252, #b33939);
            color: white;
        }
        
        .blue {
            background: linear-gradient(135deg, #227093, #1e6fa7);
            color: white;
        }
        
        .green {
            background: linear-gradient(135deg, #2ed573, #218c74);
            color: white;
        }
        
        .yellow {
            background: linear-gradient(135deg, #ffb142, #cc8e35);
            color: white;
        }
        
        .black {
            background: linear-gradient(135deg, #2c2c54, #40407a);
            color: white;
        }
        
        .opponent-card {
            background: linear-gradient(135deg, #3498db, #2980b9);
            border: 2px solid white;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        button {
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        #draw-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }
        
        #new-game-btn {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }
        
        #uno-btn {
            background: linear-gradient(135deg, #ff5252, #b33939);
            color: white;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .message {
            margin: 20px 0;
            padding: 15px 30px;
            border-radius: 50px;
            font-weight: bold;
            text-align: center;
            background: rgba(255, 255, 255, 0.2);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .message.show {
            opacity: 1;
        }
        
        .win-message {
            background: rgba(46, 213, 115, 0.3);
        }
        
        .invalid-message {
            background: rgba(255, 82, 82, 0.3);
        }
        
        .turn-indicator {
            position: absolute;
            top: -30px;
            font-size: 1.2rem;
            font-weight: bold;
            background: rgba(255, 215, 0, 0.3);
            padding: 8px 20px;
            border-radius: 20px;
        }
        
        .game-info {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
        }
        
        .info-item {
            text-align: center;
        }
        
        .info-value {
            font-size: 1.4rem;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .card {
                width: 60px;
                height: 90px;
            }
            
            .card-value {
                font-size: 1.4rem;
            }
            
            .discard-pile, .deck {
                width: 70px;
                height: 105px;
            }
            
            h1 {
                font-size: 2.5rem;
            }
            
            .player-name {
                font-size: 1.1rem;
            }
            
            button {
                padding: 12px 20px;
                font-size: 1rem;
            }
        }
        
        /* Animation for card play */
        @keyframes playCard {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .card-played {
            animation: playCard 0.5s ease;
        }
        
        /* Wild card selection modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #2c3e50, #1a1a2e);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.6);
            width: 90%;
            max-width: 400px;
        }
        
        .color-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .color-option {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .color-option:hover {
            transform: scale(1.1);
            border-color: white;
        }
        
        .color-red { background: #ff5252; }
        .color-blue { background: #3498db; }
        .color-green { background: #2ed573; }
        .color-yellow { background: #ffb142; }
    </style>
</head>
<body>
    <header>
        <h1>UNO</h1>
        <p class="subtitle">Play against the computer. Match color or value to win!</p>
    </header>
    
    <div class="game-container">
        <div class="players-info">
            <div class="player" id="player-1">
                <div class="player-name">Player 1</div>
                <div class="player-cards">Cards: <span id="player-cards-count">7</span></div>
            </div>
            <div class="player" id="player-2">
                <div class="player-name">Computer</div>
                <div class="player-cards">Cards: <span id="opponent-cards-count">7</span></div>
            </div>
        </div>
        
        <div class="game-board">
            <div class="turn-indicator" id="turn-indicator">Your turn</div>
            
            <div class="deck-area">
                <div class="deck card-back" id="deck"></div>
                <div class="discard-pile card-back" id="discard-pile">
                    <div class="discard-pile-card" id="top-card"></div>
                </div>
            </div>
            
            <div class="opponent-hand" id="opponent-hand">
                <!-- Computer's cards will be represented as card backs -->
            </div>
            
            <div class="controls">
                <button id="draw-btn">Draw Card</button>
                <button id="uno-btn">UNO!</button>
                <button id="new-game-btn">New Game</button>
            </div>
            
            <div class="player-hand" id="player-hand">
                <!-- Player's cards will be generated here -->
            </div>
            
            <div class="message" id="message"></div>
        </div>
        
        <div class="game-info">
            <div class="info-item">
                <div>Cards in Deck</div>
                <div class="info-value" id="deck-count">69</div>
            </div>
            <div class="info-item">
                <div>Current Color</div>
                <div class="info-value" id="current-color">Blue</div>
            </div>
            <div class="info-item">
                <div>Current Value</div>
                <div class="info-value" id="current-value">7</div>
            </div>
        </div>
    </div>
    
    <!-- Wild card color selection modal -->
    <div class="modal" id="color-modal">
        <div class="modal-content">
            <h2>Choose a color</h2>
            <p>Select a color for your wild card</p>
            <div class="color-options">
                <div class="color-option color-red" data-color="red"></div>
                <div class="color-option color-blue" data-color="blue"></div>
                <div class="color-option color-green" data-color="green"></div>
                <div class="color-option color-yellow" data-color="yellow"></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game state variables
            let deck = [];
            let playerHand = [];
            let opponentHand = [];
            let discardPile = [];
            let currentColor = '';
            let currentValue = '';
            let currentPlayer = 1; // 1 for player, 2 for opponent
            let gameActive = false;
            let waitingForColorSelection = false;
            
            // DOM elements
            const deckElement = document.getElementById('deck');
            const playerHandElement = document.getElementById('player-hand');
            const opponentHandElement = document.getElementById('opponent-hand');
            const topCardElement = document.getElementById('top-card');
            const drawButton = document.getElementById('draw-btn');
            const newGameButton = document.getElementById('new-game-btn');
            const unoButton = document.getElementById('uno-btn');
            const messageElement = document.getElementById('message');
            const deckCountElement = document.getElementById('deck-count');
            const playerCardsCountElement = document.getElementById('player-cards-count');
            const opponentCardsCountElement = document.getElementById('opponent-cards-count');
            const currentColorElement = document.getElementById('current-color');
            const currentValueElement = document.getElementById('current-value');
            const turnIndicatorElement = document.getElementById('turn-indicator');
            const player1Element = document.getElementById('player-1');
            const player2Element = document.getElementById('player-2');
            const colorModal = document.getElementById('color-modal');
            const colorOptions = document.querySelectorAll('.color-option');
            
            // Initialize the game
            initializeGame();
            
            // Event listeners
            drawButton.addEventListener('click', drawCard);
            newGameButton.addEventListener('click', initializeGame);
            unoButton.addEventListener('click', callUno);
            deckElement.addEventListener('click', drawCard);
            
            // Color selection for wild cards
            colorOptions.forEach(option => {
                option.addEventListener('click', () => {
                    if (waitingForColorSelection) {
                        const color = option.getAttribute('data-color');
                        currentColor = color;
                        updateCurrentColor();
                        colorModal.style.display = 'none';
                        waitingForColorSelection = false;
                        
                        // Continue with the game
                        setTimeout(() => {
                            showMessage(`Color changed to ${color}`);
                            nextTurn();
                        }, 1000);
                    }
                });
            });
            
            // Initialize game function
            function initializeGame() {
                // Clear any messages
                hideMessage();
                
                // Reset game state
                playerHand = [];
                opponentHand = [];
                discardPile = [];
                currentPlayer = 1;
                gameActive = true;
                
                // Create and shuffle the deck
                deck = createDeck();
                shuffleDeck(deck);
                
                // Deal initial cards
                for (let i = 0; i < 7; i++) {
                    playerHand.push(deck.pop());
                    opponentHand.push(deck.pop());
                }
                
                // Set up the discard pile with the first card
                let firstCard;
                do {
                    firstCard = deck.pop();
                } while (firstCard.color === 'black'); // Ensure first card isn't a wild card
                
                discardPile.push(firstCard);
                updateTopCard();
                
                // Update UI
                renderPlayerHand();
                renderOpponentHand();
                updateCounts();
                updatePlayerTurn();
                
                showMessage("Game started! Your turn.");
            }
            
            // Create a full UNO deck
            function createDeck() {
                const colors = ['red', 'blue', 'green', 'yellow'];
                const values = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'Skip', 'Reverse', 'Draw Two'];
                const deck = [];
                
                // Create number and action cards for each color
                colors.forEach(color => {
                    // Add one zero per color
                    deck.push({ color, value: '0' });
                    
                    // Add two of each number and action card per color
                    for (let i = 1; i < values.length; i++) {
                        deck.push({ color, value: values[i] });
                        deck.push({ color, value: values[i] });
                    }
                });
                
                // Add Wild cards
                for (let i = 0; i < 4; i++) {
                    deck.push({ color: 'black', value: 'Wild' });
                    deck.push({ color: 'black', value: 'Wild Draw Four' });
                }
                
                return deck;
            }
            
            // Shuffle the deck using Fisher-Yates algorithm
            function shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }
            
            // Render player's hand
            function renderPlayerHand() {
                playerHandElement.innerHTML = '';
                
                playerHand.forEach((card, index) => {
                    const cardElement = document.createElement('div');
                    cardElement.className = `card ${card.color}`;
                    cardElement.innerHTML = `
                        <span class="card-value">${card.value}</span>
                        <span class="card-color">${card.color}</span>
                    `;
                    
                    cardElement.addEventListener('click', () => playCard(index));
                    
                    playerHandElement.appendChild(cardElement);
                });
            }
            
            // Render opponent's hand (as card backs)
            function renderOpponentHand() {
                opponentHandElement.innerHTML = '';
                
                for (let i = 0; i < opponentHand.length; i++) {
                    const cardElement = document.createElement('div');
                    cardElement.className = 'card opponent-card';
                    opponentHandElement.appendChild(cardElement);
                }
            }
            
            // Update the top card display
            function updateTopCard() {
                const topCard = discardPile[discardPile.length - 1];
                currentColor = topCard.color;
                currentValue = topCard.value;
                
                topCardElement.className = `discard-pile-card ${topCard.color}`;
                topCardElement.innerHTML = `<span class="card-value">${topCard.value}</span>`;
                
                // Update current color and value displays
                currentColorElement.textContent = currentColor;
                currentValueElement.textContent = currentValue;
                currentColorElement.style.color = currentColor;
            }
            
            // Update current color display
            function updateCurrentColor() {
                currentColorElement.textContent = currentColor;
                currentColorElement.style.color = currentColor;
            }
            
            // Update card counts display
            function updateCounts() {
                deckCountElement.textContent = deck.length;
                playerCardsCountElement.textContent = playerHand.length;
                opponentCardsCountElement.textContent = opponentHand.length;
            }
            
            // Update player turn display
            function updatePlayerTurn() {
                if (currentPlayer === 1) {
                    turnIndicatorElement.textContent = "Your turn";
                    player1Element.classList.add('active');
                    player2Element.classList.remove('active');
                    drawButton.disabled = false;
                } else {
                    turnIndicatorElement.textContent = "Computer's turn";
                    player1Element.classList.remove('active');
                    player2Element.classList.add('active');
                    drawButton.disabled = true;
                    
                    // Computer's turn logic
                    setTimeout(computerTurn, 1500);
                }
            }
            
            // Draw a card from the deck
            function drawCard() {
                if (!gameActive || currentPlayer !== 1) return;
                
                if (deck.length === 0) {
                    showMessage("No more cards in the deck!", "invalid-message");
                    return;
                }
                
                const drawnCard = deck.pop();
                playerHand.push(drawnCard);
                
                renderPlayerHand();
                updateCounts();
                
                showMessage("You drew a card", "");
                
                // After drawing, it becomes opponent's turn
                setTimeout(() => {
                    currentPlayer = 2;
                    updatePlayerTurn();
                }, 1000);
            }
            
            // Play a card from player's hand
            function playCard(index) {
                if (!gameActive || currentPlayer !== 1) return;
                
                const card = playerHand[index];
                
                // Check if the card is valid to play
                if (isValidMove(card)) {
                    // Remove card from hand and add to discard pile
                    playerHand.splice(index, 1);
                    discardPile.push(card);
                    
                    // If it's a wild card, open color selection
                    if (card.color === 'black') {
                        waitingForColorSelection = true;
                        colorModal.style.display = 'flex';
                    } else {
                        // Update UI and move to next turn
                        updateTopCard();
                        renderPlayerHand();
                        updateCounts();
                        
                        // Check for win condition
                        if (playerHand.length === 0) {
                            gameActive = false;
                            showMessage("You won! 🎉", "win-message");
                            return;
                        }
                        
                        // Handle action cards
                        handleActionCard(card);
                        
                        // Move to next turn if not waiting for color selection
                        if (!waitingForColorSelection) {
                            nextTurn();
                        }
                    }
                } else {
                    showMessage("Invalid move! Match color or value.", "invalid-message");
                }
            }
            
            // Handle action cards
            function handleActionCard(card) {
                switch(card.value) {
                    case 'Skip':
                        showMessage("Skip! Opponent's turn is skipped");
                        // Skip next player's turn
                        nextTurn(); // Extra turn change to skip opponent
                        break;
                    case 'Reverse':
                        showMessage("Reverse! You get another turn");
                        // In two-player, reverse acts like a skip
                        nextTurn(); // Extra turn change to skip opponent
                        break;
                    case 'Draw Two':
                        showMessage("Draw Two! Computer draws 2 cards");
                        for (let i = 0; i < 2; i++) {
                            if (deck.length > 0) {
                                opponentHand.push(deck.pop());
                            }
                        }
                        renderOpponentHand();
                        updateCounts();
                        break;
                    case 'Wild Draw Four':
                        showMessage("Wild Draw Four! Computer draws 4 cards");
                        for (let i = 0; i < 4; i++) {
                            if (deck.length > 0) {
                                opponentHand.push(deck.pop());
                            }
                        }
                        renderOpponentHand();
                        updateCounts();
                        break;
                }
            }
            
            // Check if a card is a valid move
            function isValidMove(card) {
                const topCard = discardPile[discardPile.length - 1];
                
                // Wild cards are always valid
                if (card.color === 'black') {
                    return true;
                }
                
                // Match color or value
                if (card.color === currentColor || card.value === currentValue) {
                    return true;
                }
                
                return false;
            }
            
            // Move to the next turn
            function nextTurn() {
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                updatePlayerTurn();
            }
            
            // Computer's turn logic
            function computerTurn() {
                if (!gameActive || currentPlayer !== 2) return;
                
                // Find a valid card to play
                let playedCard = false;
                for (let i = 0; i < opponentHand.length; i++) {
                    const card = opponentHand[i];
                    if (isValidMove(card)) {
                        // Play the card
                        opponentHand.splice(i, 1);
                        discardPile.push(card);
                        
                        // If it's a wild card, computer chooses a color
                        if (card.color === 'black') {
                            // Computer chooses the color it has the most of
                            const colorCount = {
                                red: opponentHand.filter(c => c.color === 'red').length,
                                blue: opponentHand.filter(c => c.color === 'blue').length,
                                green: opponentHand.filter(c => c.color === 'green').length,
                                yellow: opponentHand.filter(c => c.color === 'yellow').length
                            };
                            
                            let maxColor = 'red';
                            let maxCount = colorCount.red;
                            
                            for (const color in colorCount) {
                                if (colorCount[color] > maxCount) {
                                    maxCount = colorCount[color];
                                    maxColor = color;
                                }
                            }
                            
                            currentColor = maxColor;
                            updateCurrentColor();
                            showMessage(`Computer played Wild and changed color to ${maxColor}`);
                        } else {
                            currentColor = card.color;
                            currentValue = card.value;
                            updateTopCard();
                            showMessage(`Computer played a card`);
                        }
                        
                        playedCard = true;
                        
                        // Check for win condition
                        if (opponentHand.length === 0) {
                            gameActive = false;
                            showMessage("Computer won! 😢", "invalid-message");
                            return;
                        }
                        
                        // Handle action cards
                        handleComputerActionCard(card);
                        
                        break;
                    }
                }
                
                // If no valid card, draw a card
                if (!playedCard) {
                    if (deck.length > 0) {
                        opponentHand.push(deck.pop());
                        showMessage("Computer drew a card");
                    } else {
                        showMessage("Computer couldn't draw a card - deck is empty");
                    }
                }
                
                // Update UI
                renderOpponentHand();
                updateCounts();
                
                // Move to player's turn after a delay
                setTimeout(() => {
                    if (gameActive) {
                        currentPlayer = 1;
                        updatePlayerTurn();
                    }
                }, 2000);
            }
            
            // Handle computer action cards
            function handleComputerActionCard(card) {
                switch(card.value) {
                    case 'Skip':
                        showMessage("Computer skipped your turn!");
                        // Skip player's turn - computer gets another turn
                        setTimeout(computerTurn, 1500);
                        break;
                    case 'Reverse':
                        showMessage("Computer reversed! It gets another turn");
                        // In two-player, reverse acts like a skip
                        setTimeout(computerTurn, 1500);
                        break;
                    case 'Draw Two':
                        showMessage("Draw Two! You draw 2 cards");
                        for (let i = 0; i < 2; i++) {
                            if (deck.length > 0) {
                                playerHand.push(deck.pop());
                            }
                        }
                        renderPlayerHand();
                        updateCounts();
                        break;
                    case 'Wild Draw Four':
                        showMessage("Wild Draw Four! You draw 4 cards");
                        for (let i = 0; i < 4; i++) {
                            if (deck.length > 0) {
                                playerHand.push(deck.pop());
                            }
                        }
                        renderPlayerHand();
                        updateCounts();
                        break;
                }
            }
            
            // Call UNO when player has one card left
            function callUno() {
                if (playerHand.length === 1) {
                    showMessage("UNO! You have one card left", "win-message");
                } else {
                    showMessage("You can only call UNO when you have one card!", "invalid-message");
                }
            }
            
            // Show message to player
            function showMessage(text, className = "") {
                messageElement.textContent = text;
                messageElement.className = `message show ${className}`;
                
                // Auto-hide message after 3 seconds
                setTimeout(hideMessage, 3000);
            }
            
            // Hide message
            function hideMessage() {
                messageElement.className = 'message';
            }
        });
    </script>
</body>
</html>
